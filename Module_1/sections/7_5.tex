To overcome the limitations of linear planners that explore the \textbf{state space}, the field shifts to \textbf{non-linear planners}, specifically \textbf{Partial Order 
Planning}, which instead operate within the 
\textbf{plan space}. \vspace{3.5pt}

A non-linear planner treats a plan as an object that is gradually refined. It has two main charateristics, which are:
\begin{itemize}[nosep]
    \renewcommand{\labelitemi}{-}
    \item \textbf{Search space}. \\ Each node of the tree search represents a \textbf{partial plan}, and the operators are \textbf{plan refinement moves}.
    \item \textbf{Least commitment planning}. \\ The planner avoids imposing decisions and orderings that are not strictly necessary. This strategy allow us to reduce the amount of backtracking actions required by linear planners.
\end{itemize}

A plan, defined by this type of planners, is represented as:
\begin{itemize}[nosep]
    \renewcommand{\labelitemi}{-}
    \item A set of \textbf{actions}.
    \item A set of \textbf{casual links}.
    \item A set of \textbf{partial orderings} between the actions. For example, taking two actions $A$ and $B$, the order $A < B$, means that the action $A$ comes before the action $B$.
\end{itemize}

Each plan starts with two fake actions, described as follows:
\begin{itemize}[nosep]
    \renewcommand{\labelitemi}{}
    \item $1^{st}$ \textbf{Start action}. \\ It is an action \textbf{without preconditions} and its effects match the initial state. Therefore, it relies only to the \textbf{initial state}.
    \item $2^{nd}$ \textbf{Stop action}. \\ Unlike the start one, the stop action is an action \textbf{without postconditions} and its preconditions match the goal state. Therefore, it relies only to the \textbf{goal state}.
    \item $3^{rd}$ \textbf{Ordering}. \\ From these two actions we can derive a general rule: \textit{start action} $<$ \textit{stop action}. In other words, in any plan designed by a non-linear planner the start action comes before the stop action.
\end{itemize}

The chore mechanisms for managing goal interaction in POP involves \textbf{casual links} and the resolution of \textbf{threats}.
\begin{itemize}[nosep]
    \renewcommand{\labelitemi}{-}
    \item \textbf{Casual links}. \\ A casual link, denoted $\langle S_i, C, S_j\rangle$, is a triple indicating that the action $S_i$ defines the condition $C$ required as precondition for the action $S_j$. In addition, a casual link stores the causal relations between actions: it traces why a given operator has been introduced in the plan.
    \item \textbf{Threats}. \\ An action, $S_k$, is a \textbf{threat} to a casual link $\langle S_i, C, S_j\rangle$ if $S_k$ has an effect that negates the condition $C$, and no existing ordering constraint prevents $S_k$ from being executed between $S_i$ and $S_j$.
\end{itemize}

Threats must be resolved to ensure the established condition $C$ remains true when the actions $S_j$ is executed. The two primary strategies are:
\begin{itemize}[nosep]
    \renewcommand{\labelitemi}{-}
    \item \textbf{Demotion}: imposing the ordering $S_k < S_i$, ensures the destructive action $S_k$ occurs \textbf{before} the casual link.
    \item \textbf{Promotion}: imposing the ordering $S_j < S_k$, ensures the destructive action $S_k$ occurs \textbf{after} the casual link.
\end{itemize}
\begin{example}
    i.e. Purchasing schedule. \vspace{3.5pt}

    Given an initial state \vspace{7pt}
    \begin{center}
        \begin{tabular}{l}
            \textbf{Initial state} \\
            $sells(sm, banana), sells(sm, milk)$ \\
            $sells(HWS, drill)$ \\
            $at(home)$ 
        \end{tabular}
    \end{center} \vspace{3.5pt}
    define a plan that bring us to the following goal state \vspace{7pt}
    \begin{center}
        \begin{tabular}{l}
            \textbf{Goal state} \\
            $have(milk), have(banana)$ \\
            $have(drill)$ \\
            $at(home)$
        \end{tabular}
    \end{center} \vspace{7pt}
    The executable actions are: \vspace{7pt}
    \begin{center}
        \begin{tabular}{ll}
            \textbf{Go(X,Y)} & \textbf{Buy(S,Y)} \\
            Precond: $at(X)$ & Precond: $at(S), sells(S,Y)$ \\
            Effect: $at(Y), \neg at(X)$\footnote{This effect list is represented as the conjuction of the add and delete list.} & Effect: $have(Y)$ \\
        \end{tabular}
    \end{center} \vspace{21pt}

    \begin{center}
        \includegraphics[width=0.65\textwidth]{img/img17.png}
    \end{center} \vspace{3.5pt}

    \begin{itemize}[nosep]
        \renewcommand{\labelitemi}{}
        \item $1^{st}$ step: 
            \begin{itemize}[nosep]
                \renewcommand{\labelitemii}{-}
                \item Select a precondition from the goal state to be fulfilled: $have(drill)$.
                \item Select an action that has the precondition $have(drill)$ as postcondition: $buy(S,Y)$.
                \item Represent the plan refinement: 
                    \begin{itemize}[nosep]
                        \renewcommand{\labelitemiii}{-}
                        \item Link the variable $Y$ with the term $drill$.
                        \item Impose ordering constraint: $start < buy(S,drill) < stop$.
                        \item Insert the casual link $\langle buy(S,drill), have(drill), stop \rangle$.
                    \end{itemize}
            \end{itemize}
        \item $2^{nd}$ step: 
        \begin{itemize}[nosep]
            \renewcommand{\labelitemii}{-}
            \item Same process in the first step for $have(milk)$.
            \item Same process in the first step for $have(banana)$.
        \end{itemize} \vspace{3.5pt}

        \begin{center}
            \includegraphics[width=0.7\textwidth]{img/img18.png}
        \end{center} \vspace{3.5pt}
        \item $3^{rd}$ step:  
        \begin{itemize}[nosep]
            \renewcommand{\labelitemii}{-}
            \item Select a precondition from the $buy(S,drill)$ state to be fulfilled: $sells(S,drill)$.
            \item Select an action that has the precondition $sells(S,drill)$ as postcondition: $start$.
            \item Represent the plan refinement: 
                \begin{itemize}[nosep]
                    \renewcommand{\labelitemiii}{-}
                    \item Link the variable $s$ with the term $HWS$.
                    \item Impose ordering constraint: $start < buy(HWS,drill) < stop$.
                    \item Insert the casual link \\ $\langle start, sells(HWS, drill), buy(HWS, drill) \rangle$.
                \end{itemize}
        \end{itemize}
        \item $4^{th}$ step:
        \begin{itemize}[nosep]
            \renewcommand{\labelitemii}{-}
            \item Same process in the third step for $sells(S,milk)$.
            \item Same process in the third step for $sells(S,banana)$.
        \end{itemize} \vspace{3.5pt}

        \begin{center}
            \includegraphics[width=0.7\textwidth]{img/img19.png}
        \end{center} \vspace{3.5pt}
        \item $5^{th}$ step:  
        \begin{itemize}[nosep]
            \renewcommand{\labelitemii}{-}
            \item Select a precondition not yet satisfied: $at(HWS)$.
            \item Select an action that has the precondition $at(HWS)$ as postcondition: $go(X,HWS)$.
            \item Represent the plan refinement: 
                \begin{itemize}[nosep]
                    \renewcommand{\labelitemiii}{-}
                    \item Impose ordering constraint: \\ $start < go(X,HWS) < buy(HWS, drill)$.
                    \item Insert the casual link $\langle start, at(X), go(X, HWS) \rangle$.
                \end{itemize}
        \end{itemize}
        \item $6^{th}$ step:  
        \begin{itemize}[nosep]
            \renewcommand{\labelitemii}{-}
            \item Select a precondition not yet satisfied: $at(X)$.
            \item Select an action that has the precondition $at(X)$ as postcondition: $start$.
            \item Represent the plan refinement: 
                \begin{itemize}[nosep]
                    \renewcommand{\labelitemiii}{-}
                    \item Link the variable $X$ to $home$.
                    \item Redefine the ordering constraint: $start < go(home,HWS) < buy(HWS, drill)$.
                    \item Redefine the casual link $\langle start, at(home), go(home, HWS) \rangle$.
                \end{itemize}
        \end{itemize}
        \item $7^{th}$ step:
            \begin{itemize}[nosep]
                \renewcommand{\labelitemii}{-}
                \item Same process in the fifth and sixth step for $at(sm)$.
            \end{itemize} \vspace{3.5pt}

            \begin{center}
                \includegraphics[width=0.7\textwidth]{img/img20.png}
            \end{center} \vspace{3.5pt}
    \end{itemize}
    After few steps, one huge problem comes out: the planner cannot perform at the same time the procedure $go(home,HWS)$ and $go(home,sm)$ from the start action. Demotion and
    promotion in this case are not enough to solve the problem, any constraint ordering does not work. \vspace{3.5pt}

    Instead of going back at $home$ between stores, we take as advantage the \textbf{current position}. The planner decides to satisfy the precondition $at(sm)$ not from the
    \textbf{start action}, but \textbf{after} the procedure $go(home,HWS)$. At the end, we have a constraint ordering as follows: $buy(HWS, drill) < go(HWS, sm)$. \vspace{3.5pt}

    \begin{center}
        \includegraphics[width=0.55\textwidth]{img/img21.png}
    \end{center} \vspace{3.5pt}
    \begin{itemize}[nosep]
        \renewcommand{\labelitemi}{}
        \item $8^{st}$ step: 
            \begin{itemize}[nosep]
                \renewcommand{\labelitemii}{-}
                \item Solve the preconditions $at(home)$ of the stop action.
                \item The only way to do this is to put the action $go(X,home)$ before the stop action.
            \end{itemize}
    \end{itemize} \vspace{3.5pt}

    \begin{center}
        \includegraphics[width=0.45\textwidth]{img/img22.png}
    \end{center} \vspace{3.5pt}
\end{example}
The eighth step is named the \textbf{white knight}, a refinement strategy which inserts a new operator in the plan between two conflict actions\footnote{We remember that two actions are in conflict when the effect of any procedure $S_i$ negate the preconditions of any procedure $S_j$.}.

Let's examine an other example.
\begin{example}
    i.e. Sussman anomaly. \vspace{3.5pt}

    Given an initial state \vspace{7pt}
    \begin{center}
        \begin{tabular}{l}
            \textbf{Initial state} \\
            $ontable(a), ontable(b)$ \\
            $clear(b), clear(c)$ \\
            $on(c,a)$ 
        \end{tabular}
    \end{center} \vspace{3.5pt}
    define a plan that reaches the goal state \vspace{7pt}
    \begin{center}
        \begin{tabular}{l}
            \textbf{Goal state} \\
            $on(b,c) \land on(c,a)$
        \end{tabular}
    \end{center}
    The executable actions are: \vspace{7pt}
    \begin{center}
        \begin{tabular}{l}
            \textbf{Putdown(X)} \\
            Precond: $holding(X)$ \\
            Effect: $handempty, clear(X), ontable(X), \neg \text{Precond}$
        \end{tabular} \vspace{7pt}

        \begin{tabular}{l}
            \textbf{Stack(X,Y)} \\
            Precond: $holding(X), clear(Y)$ \\
            Effect: $handempty, on(X,Y), clear(X), \neg \text{Precond}$\footnote{To save space, we did not list every precondition that was denied by the action.}
        \end{tabular} \vspace{7pt}

        \begin{tabular}{l}
            \textbf{Pickup(X)} \\
            Precond: $handempty, clear(X), ontable(X)$ \\
            Effect: $holding(X), \neg \text{Precond}$
        \end{tabular} \vspace{7pt}

        \begin{tabular}{l}
            \textbf{Unstack(X,Y)} \\
            Precond: $handempty, on(X,Y), clear(Y)$ \\
            Effect: $holding(X), clear(Y), \neg \text{Precond}$
        \end{tabular} \vspace{7pt}
    \end{center} \vspace{3.5pt}

    Here we are trying to solve the \textbf{Sussman anomaly} using POP. As usual, we have to define the initial empty plan, containing two fake actions: the start action and
    the stop action. \vspace{3.5pt}
    
    \begin{center}
        \includegraphics[width=0.5\textwidth]{img/img23.png}
    \end{center} \vspace{3.5pt}

    \begin{itemize}[nosep]
        \renewcommand{\labelitemi}{}
        \item $1^{st}$ step: 
            \begin{itemize}[nosep]
                \renewcommand{\labelitemii}{-}
                \item Select a precondition from the goal state to be fulfilled: $on(b,c)$.
                \item Select an action that has the precondition $on(b,c)$ as postcondition: $stack(b,c)$.
                \item Represent the plan refinement: 
                    \begin{itemize}[nosep]
                        \renewcommand{\labelitemiii}{-}
                        \item Impose ordering constraint: $start < stack(b,c) < stop$.
                        \item Insert the casual link $\langle stack(b,c), on(b,c), stop \rangle$.
                    \end{itemize}
            \end{itemize}
        \item $2^{nd}$ step: 
            \begin{itemize}[nosep]
                \renewcommand{\labelitemii}{-}
                \item Same process in the first step for $on(c,a)$.
            \end{itemize} \vspace{3.5pt}

            \begin{center}
                \includegraphics[width=0.7\textwidth]{img/img24.png}
            \end{center} \vspace{3.5pt}
        \item $3^{rd}$ step: 
            \begin{itemize}[nosep]
                \renewcommand{\labelitemii}{-}
                \item Select a precondition from the $stack(c,b)$ state to be fulfilled: $holding(b)$.
                \item Select an action that has the precondition $holding(b)$ as postcondition: $pickup(b)$ or $unstack(b,Y)$.
                \item Since the initial state defines the block $b$ is on the table, we should perform the $pickup(X)$ action.
                \item Represent the plan refinement:
                    \begin{itemize}[nosep]
                        \renewcommand{\labelitemiii}{-}
                        \item Impose ordering constraint: $start < pickup(b) < stack(b,c)$.
                        \item Insert the casual link $\langle pickup(b), holding(b), stack(b,c) \rangle$.
                    \end{itemize}
            \end{itemize}
            All the $pickup(b)$ preconditions are already satisfied by the $\text{start action}$. Therefore, we have to insert the casual link from the start action to 
            the pickup(\dots) action. In addition, as we can see, the precondition $clear(c)$ of the action $stack(b,c)$ is already satisfied by the knowledge base given
            by the start action. \vspace{3.5pt}
        \item $4^{th}$ step:
            \begin{itemize}[nosep]
                \renewcommand{\labelitemii}{-}
                \item Exactly the same procedure described in the previous step occurs for $stack(a,c)$ predicate.
            \end{itemize} \vspace{3.5pt}

            \begin{center}
                \includegraphics[width=0.8\textwidth]{img/img25.png}
            \end{center} \vspace{3.5pt}
    \end{itemize}

    By this initial formalization, some \textbf{threats} are already coming out, which are:
    \begin{itemize}[nosep]
        \renewcommand{\labelitemi}{-}
        \item Performing the action $pickup(b)$ negates the $handempty$ precondition necessary for the predicate $pickup(a)$. This problem can be easily solved by imposing a \textbf{promotion} ordering constraint. The action $pickup(a)$ must be executed after the predicate $stack(b,c)$, in other words $stack(b,c) < pickup(a)$.
        \item If the first subgoal $on(b,c)$ is reached, then it's impossible to execute the action $stack(a,b)$ given this initial state. Any ordering constraint cannot solve this situation.
    \end{itemize}

    Following this ordering constraint, the planner must perform backtracking, forcing the exploration of a new planning strategy and, consequently, losing computational 
    efficiency. The unique solution in this case is to think outside the main scheme, reasoning about how all the different actions can be linked together. \vspace{3.5pt}

    The main intuition is: before performing $stack(b,c)$ action we have to \textbf{unstack}\footnote{Unstack action is a white knight strategy, we are inserting a new action inside the initial plan.}
    the block $c$ over the block $a$. Holding the block $c$, the next move will put it down on the table. Finally, the $handempty$ condition will be true, allowing us
    to execute all the \textbf{stack(\dots)} predicates. The final ordering scheme is shown below. \vspace{3.5pt}

    \begin{center}
        $start < unstack(c,a) < putdown(c) < pickup(b) < ...$ \\ $... < stack(b,c) < pickup(a) < stack(a,b) < stop$ \vspace{7pt}

        \includegraphics[width=0.8\textwidth]{img/img26.png}
    \end{center} \vspace{3.5pt}
\end{example}
\dots